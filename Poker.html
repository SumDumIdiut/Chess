<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a3a, #2d1b69, #4c1d95, #5b21b6);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 0.8s ease-out;
        }

        .header h1 {
            font-size: 3em;
            color: #8b5cf6;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .menu-screen {
            background: rgba(30, 27, 75, 0.4);
            border-radius: 20px;
            padding: 40px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            animation: fadeIn 1s ease-out;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .game-modes {
            display: flex;
            gap: 60px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 60px;
            margin-top: 120px;
        }

        .mode-btn {
            padding: 50px 100px;
            font-size: 2.5em;
            background: linear-gradient(145deg, #3b82f6, #8b5cf6);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 12px 32px rgba(59, 130, 246, 0.4);
            font-weight: bold;
            margin: 30px 0;
        }

        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px rgba(139, 92, 246, 0.4);
            background: linear-gradient(145deg, #8b5cf6, #3b82f6);
        }

        .online-setup {
            display: none;
            background: rgba(30, 27, 75, 0.5);
            padding: 30px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #8b5cf6;
            font-size: 1.1em;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #8b5cf6;
            border-radius: 8px;
            background: rgba(30, 27, 75, 0.7);
            color: white;
            outline: none;
        }
        /* Custom styled checkbox for blinds */
        .blind-checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
            color: #8b5cf6;
            margin-bottom: 8px;
            cursor: pointer;
            user-select: none;
        }
        .blind-checkbox-label input[type="checkbox"] {
            accent-color: #8b5cf6;
            width: 20px;
            height: 20px;
            margin-right: 6px;
            border-radius: 6px;
            border: 2px solid #8b5cf6;
            background: rgba(30, 27, 75, 0.7);
            cursor: pointer;
        }
        .blind-checkbox-label .custom-checkbox {
            display: none;
        }

        .lobby-screen {
            display: none;
            animation: fadeIn 0.8s ease-out;
            min-height: 100vh;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 0;
        }

        .lobby-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
            width: 100vw;
            min-height: 500px;
            box-sizing: border-box;
            background: rgba(30, 27, 75, 0.5);
            border-radius: 0 0 30px 30px;
        }

        .lobby-panel {
            background: rgba(30, 27, 75, 0.4);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .lobby-panel h3 {
            color: #8b5cf6;
            margin-bottom: 15px;
            font-size: 1.3em;
            text-align: center;
        }

        .players-list {
            list-style: none;
        }

        .player-item {
            background: rgba(59, 130, 246, 0.2);
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border: 1px solid rgba(139, 92, 246, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.host {
            background: rgba(139, 92, 246, 0.3);
            border-color: #8b5cf6;
        }

        .player-status {
            font-size: 0.9em;
            color: #a855f7;
        }

        .room-info {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 20px;
        }

        .room-code {
            font-size: 2em;
            color: #8b5cf6;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .game-variant {
            font-size: 1.2em;
            color: #a855f7;
        }

        .variant-selector {
            margin: 20px 0;
        }

        .variant-selector select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #8b5cf6;
            border-radius: 8px;
            background: rgba(30, 27, 75, 0.7);
            color: white;
            outline: none;
        }

        /* NEW: Add bot button style */
        .add-bot-btn {
            padding: 15px;
            font-size: 1em;
            background: linear-gradient(145deg, #f59e0b, #f97316);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(245, 158, 11, 0.3);
            font-weight: bold;
            margin-top: 15px;
            width: 100%;
        }

        .add-bot-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(245, 158, 11, 0.4);
        }

        .host-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
        }

        .start-game-btn {
            padding: 20px;
            font-size: 1.4em;
            background: linear-gradient(145deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 16px rgba(16, 185, 129, 0.3);
            font-weight: bold;
        }

        .start-game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px rgba(16, 185, 129, 0.4);
        }

        .start-game-btn:disabled {
            background: linear-gradient(145deg, #6b7280, #4b5563);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .lobby-message {
            text-align: center;
            padding: 15px;
            background: rgba(30, 27, 75, 0.5);
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #8b5cf6;
        }

        .copy-code-btn {
            padding: 10px 15px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        .copy-code-btn:hover {
            background: #6d28d9;
        }

        .game-screen {
            display: none;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(30, 27, 75, 0.5);
            border-radius: 10px;
        }

        .poker-table {
            background: radial-gradient(ellipse, #2563eb, #1e40af);
            border: 8px solid #4c1d95;
            border-radius: 200px;
            padding: 40px;
            margin: 20px auto;
            min-height: 400px;
            position: relative;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .card {
            width: 80px;
            height: 112px;
            background: white;
            border: 2px solid #333;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 1.2em;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
        }
        .community-cards .card {
            width: 160px;
            height: 220px;
            font-size: 2.5em;
            padding: 24px;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card.back {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            color: white;
            justify-content: center;
        }

        .players {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .player {
            background: rgba(30, 27, 75, 0.7);
            border: 2px solid #8b5cf6;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            min-width: 150px;
            margin: 5px;
        }

        .player.active {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }

        .player.folded {
            opacity: 0.5;
            border-color: #6b7280;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 10px 0;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 24px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .control-btn.fold {
            background: #7c3aed;
            color: white;
        }

        .control-btn.call {
            background: #3b82f6;
            color: white;
        }

        .control-btn.raise {
            background: #8b5cf6;
            color: white;
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .bet-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .bet-input input {
            padding: 8px;
            border: 2px solid #8b5cf6;
            border-radius: 5px;
            background: rgba(30, 27, 75, 0.7);
            color: white;
            width: 100px;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .status-message {
            text-align: center;
            padding: 15px;
            background: rgba(30, 27, 75, 0.7);
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #8b5cf6;
        }

        @media (max-width: 1024px) {
            .lobby-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .lobby-panel {
                min-height: auto;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .game-modes {
                flex-direction: column;
                align-items: center;
            }
            
            .mode-btn {
                width: 100%;
                max-width: 300px;
            }
            
            .players {
                flex-direction: column;
                gap: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .control-btn {
                width: 100%;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Removed header title as requested -->

        <!-- Menu Screen -->
        <div id="menuScreen" class="menu-screen">
            <div class="game-modes">
                <button class="mode-btn" onclick="startOfflineGame()">Play Offline</button>
                <button class="mode-btn" onclick="showOnlineSetup()">Play Online</button>
            </div>
            <div id="onlineSetup" class="online-setup">
                <div class="input-group">
                    <label for="playerName">Your Name</label>
                    <input type="text" id="playerName" placeholder="Enter your name">
                </div>
                <div class="input-group">
                    <label for="roomCode">Room Code (leave blank to create)</label>
                    <input type="text" id="roomCode" placeholder="Enter room code">
                </div>
                <button class="mode-btn" onclick="joinOrCreateLobby()">Join / Create Lobby</button>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="lobby-screen">
            <div class="lobby-container">
                <div class="lobby-panel">
                    <h3>Players</h3>
                    <ul id="playersList" class="players-list"></ul>
                </div>
                <div class="lobby-panel room-info">
                    <div>
                        <h3 class="room-code-header">Room Code</h3>
                        <div class="room-code" id="lobbyRoomCode"></div>
                        <button class="copy-code-btn" onclick="copyRoomCode()">Copy Code</button>
                    </div>
                    <div class="game-variant" id="lobbyGameVariant"></div>
                </div>
                <div class="lobby-panel host-controls">
                    <h3>Host Controls</h3>
                    <div class="variant-selector">
                        <label for="variantSelect">Game Variant</label>
                        <select id="variantSelect" onchange="onVariantChanged(this.value)">
                            <option value="texas-holdem">Texas Hold'em</option>
                            <option value="omaha">Omaha</option>
                            <option value="five-card-draw">Five Card Draw</option>
                        </select>
                    </div>
                    <div class="input-group" id="blindOptionsGroup" style="margin-bottom: 10px;">
                        <label class="blind-checkbox-label">
                            <input type="checkbox" id="enableSmallBlind" checked>
                            <span class="custom-checkbox"></span>
                            Enable Small Blind
                        </label>
                        <label class="blind-checkbox-label">
                            <input type="checkbox" id="enableBigBlind" checked>
                            <span class="custom-checkbox"></span>
                            Enable Big Blind
                        </label>
                    </div>
                    <button class="add-bot-btn" onclick="addBot()">Add Bot</button>
                    <button id="startGameBtn" class="start-game-btn" onclick="startOnlineGame()">Start Game</button>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="game-screen">
            <button class="back-btn" onclick="backToMenu()">← Back to Menu</button>

            <div class="game-info">
                <div>
                    <strong>Game:</strong> <span id="currentVariant">Texas Hold'em</span>
                </div>
                <div>
                    <strong>Pot:</strong> $<span id="potAmount">0</span>
                </div>
                <div>
                    <strong>Current Bet:</strong> $<span id="currentBet">0</span>
                </div>
            </div>

            <div class="status-message" id="statusMessage">
                Welcome to Ultimate Poker! The first hand will begin shortly.
            </div>

            <div class="poker-table">
                <div class="community-cards" id="communityCards">
                    <!-- Community cards will be added here -->
                </div>
            </div>

            <div class="players" id="playersContainer">
                <!-- Players will be added here -->
            </div>

            <div class="controls">
                <button class="control-btn fold" onclick="playerAction('fold')" id="foldBtn" style="display: none;">Fold</button>
                <button class="control-btn call" onclick="playerAction('call')" id="callBtn" style="display: none;">Call</button>
                <button class="control-btn raise" onclick="playerAction('raise')" id="raiseBtn" style="display: none;">Raise</button>
                
                <div class="bet-input" id="betInputContainer">
                    <label for="betAmount" title="Enter the amount you want to raise by">Raise Amount:</label>
                    <input type="number" id="betAmount" min="1" step="1" placeholder="Enter raise amount" value="10" style="width: 120px;">
                </div>
                <button class="control-btn" id="nextHandBtn" style="display:none; margin-left:20px; background: #10b981; color: white;">Next Hand</button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            variant: 'texas-holdem',
            mode: 'offline',
            players: [],
            currentPlayer: 0,
            pot: 0,
            currentBet: 0,
            communityCards: [],
            deck: [],
            gamePhase: 'preflop', // can be 'preflop', 'flop', 'turn', 'river', 'showdown'
            currentStreet: 0, // 0=preflop, 1=flop, 2=turn, 3=river
            gameActive: false,
            dealerPosition: -1, // Start at -1 so first hand is player 0
            smallBlind: 5,
            bigBlind: 10,
            lastRaiser: null
        };

        // Card deck
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

        function createDeck() {
            const deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({
                        rank: rank,
                        suit: suit,
                        color: (suit === '♥' || suit === '♦') ? 'red' : 'black'
                    });
                }
            }
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function createCard(card, faceDown = false) {
            const cardElement = document.createElement('div');
            cardElement.className = `card ${faceDown ? 'back' : card.color}`;
            
            if (faceDown) {
                cardElement.innerHTML = '🂠';
            } else {
                cardElement.innerHTML = `
                    <div>${card.rank}</div>
                    <div style="font-size: 1.5em;">${card.suit}</div>
                    <div style="transform: rotate(180deg);">${card.rank}</div>
                `;
            }
            
            return cardElement;
        }


        function showOnlineSetup() {
            document.getElementById('onlineSetup').style.display = 'block';
        }

        // Global variable to track game polling interval
        window.pokerGameSyncInterval = null;

        function joinOrCreateLobby() {
            const playerName = document.getElementById('playerName').value;
            if (!playerName) {
                alert('Please enter your name.');
                return;
            }

            // Store the current player's name globally
            window.currentPlayerName = playerName;

            const roomCodeInput = document.getElementById('roomCode').value.trim();
            const isCreating = roomCodeInput === '';
            const lobbyContainer = document.querySelector('.lobby-container');

            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            // Auto-reload the page once to fix lobby layout
            if (window.location.hash !== '#lobby') {
                window.location.hash = '#lobby';
                window.location.reload();
                return;
            }
            // Force reflow and set grid columns/width after lobby is visible
            setTimeout(() => {
                if (isCreating) {
                    lobbyContainer.style.gridTemplateColumns = '300px 1fr 300px';
                } else {
                    lobbyContainer.style.gridTemplateColumns = '300px 1fr';
                }
                lobbyContainer.style.width = '100vw';
                lobbyContainer.style.boxSizing = 'border-box';
                // Force reflow
                void lobbyContainer.offsetHeight;
            }, 0);

            let roomData;
            let roomCode;

            if (isCreating) {
                const newRoomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
                roomData = {
                    code: newRoomCode,
                    players: [{ name: playerName, isHost: true, chips: 1000 }],
                    variant: 'texas-holdem'
                };
                roomCode = newRoomCode;
                document.querySelector('.host-controls').style.display = 'flex';
            } else {
                roomData = JSON.parse(localStorage.getItem(roomCodeInput));
                if (!roomData) {
                    alert('Room not found!');
                    backToMenu();
                    return;
                }
                // Only add player if not already in the list
                let existing = roomData.players.find(p => p.name === playerName);
                if (!existing) {
                    roomData.players.push({ name: playerName, isHost: false, chips: 1000 });
                }
                roomCode = roomCodeInput;
                document.querySelector('.host-controls').style.display = 'none';
            }
            
            localStorage.setItem(roomData.code, JSON.stringify(roomData));
            
            // Periodically update the lobby from localStorage
            setInterval(() => updateLobbyUI(roomData.code), 1000);

            // All players poll for game start
            if (window.lobbyGameStartInterval) clearInterval(window.lobbyGameStartInterval);
            window.lobbyGameStartInterval = setInterval(() => {
                const updatedRoomData = JSON.parse(localStorage.getItem(roomData.code));
                if (updatedRoomData && updatedRoomData.gameStarted) {
                    clearInterval(window.lobbyGameStartInterval);
                    // Load game state and transition to game screen
                    const storedGameState = JSON.parse(localStorage.getItem(`game_${roomData.code}`));
                    // Use the globally stored player name
                    const isYouName = window.currentPlayerName;
                    gameState = storedGameState;
                    const me = gameState.players.find(p => p.name === isYouName);
                    if (me) {
                        gameState.players.forEach(p => p.isYou = (p.name === me.name));
                    }
                    document.getElementById('lobbyScreen').style.display = 'none';
                    document.getElementById('gameScreen').style.display = 'block';
                    updateGameUI();
                    showPlayerActions();

                    // Start polling for game state sync for all players
                    if (window.pokerGameSyncInterval) clearInterval(window.pokerGameSyncInterval);
                    const roomCode = roomData.code;
                    window.pokerGameSyncInterval = setInterval(() => {
                        const storedGameState = JSON.parse(localStorage.getItem(`game_${roomCode}`));
                        if (storedGameState) {
                            // Set isYou for the current player
                            const isYouName = window.currentPlayerName;
                            storedGameState.players.forEach(p => p.isYou = (p.name === isYouName));
                            // If game is over, return to menu
                            if (storedGameState.gameOver) {
                                clearInterval(window.pokerGameSyncInterval);
                                setTimeout(() => {
                    document.getElementById('gameScreen').style.display = 'none';
                                    document.getElementById('lobbyScreen').style.display = 'block';
                                }, 1000);
                                return;
                            }
                            // Only update if state actually changed
                            if (JSON.stringify(gameState) !== JSON.stringify(storedGameState)) {
                                gameState = storedGameState;
                                updateGameUI();
                                showPlayerActions();
                            }
                        }
                    }, 500);
                }
            }, 1000);
        }

        function copyRoomCode() {
            const roomCode = document.getElementById('lobbyRoomCode').textContent;
            navigator.clipboard.writeText(roomCode).then(() => {
                alert('Room code copied to clipboard!');
            });
        }

        function addBot() {
            const roomCode = document.getElementById('lobbyRoomCode').textContent;
            let roomData = JSON.parse(localStorage.getItem(roomCode));
            if (roomData) {
                const botName = `Bot ${Math.floor(Math.random() * 100)}`;
                roomData.players.push({ name: botName, isHost: false, isBot: true });
                localStorage.setItem(roomCode, JSON.stringify(roomData));
                updateLobbyUI(roomCode);
            }
        }

        function onVariantChanged(variant) {
            gameState.variant = variant;
            document.getElementById('lobbyGameVariant').textContent = `Variant: ${variant}`;
            // If in online mode and in a room, update the room data in localStorage
            const roomCode = document.getElementById('lobbyRoomCode')?.textContent;
            if (roomCode) {
                let roomData = JSON.parse(localStorage.getItem(roomCode));
                if (roomData) {
                    roomData.variant = variant;
                    localStorage.setItem(roomCode, JSON.stringify(roomData));
                }
            }
        }

        function startOnlineGame() {
            const roomCode = document.getElementById('lobbyRoomCode').textContent;
            let roomData = JSON.parse(localStorage.getItem(roomCode));
            if (!roomData) {
                alert('Could not start game. Room data not found.');
                return;
            }

            // Use the globally stored player name
            const currentPlayerName = window.currentPlayerName;
            const isHost = roomData.players.find(p => p.name === currentPlayerName)?.isHost;

            if (isHost) {
                // Read blind settings from tickboxes in the lobby
                const enableSmallBlind = document.getElementById('enableSmallBlind')?.checked;
                const enableBigBlind = document.getElementById('enableBigBlind')?.checked;
                roomData.smallBlind = enableSmallBlind ? 5 : 0;
                roomData.bigBlind = enableBigBlind ? 10 : 0;
                roomData.gameStarted = true;
                localStorage.setItem(roomCode, JSON.stringify(roomData));
                
                // Host sets up the game state and saves it
                // Use chips from last game state if available
                let lastGameState = null;
                try {
                    lastGameState = JSON.parse(localStorage.getItem(`game_${roomCode}`));
                } catch (e) { lastGameState = null; }
                const initialPlayers = roomData.players.map(p => {
                    // Always reset chips to 1000 for a new game
                    return {
                        ...p,
                        chips: 1000,
                        cards: [],
                        bet: 0,
                        isHuman: !p.isBot,
                        isActive: true,
                        hasFolded: false
                    };
                });

                const deck = createDeck();
                let cardsToDeal = 2;
                initialPlayers.forEach(player => {
                    for (let i = 0; i < cardsToDeal; i++) {
                        player.cards.push(deck.pop());
                    }
                });

                Object.assign(gameState, {
                    players: initialPlayers,
                    deck: deck,
                    gameActive: true,
                    mode: 'online',
                    smallBlind: roomData.smallBlind ?? 5,
                    bigBlind: roomData.bigBlind ?? 10
                });

                localStorage.setItem(`game_${roomCode}`, JSON.stringify(gameState));
            }
            // No need to poll here; all players already poll in joinOrCreateLobby
        }

        function startOfflineGame() {
            gameState.mode = 'offline';
            // Read blind settings from checkboxes
            const enableSmallBlind = document.getElementById('enableSmallBlind')?.checked;
            const enableBigBlind = document.getElementById('enableBigBlind')?.checked;
            gameState.smallBlind = enableSmallBlind ? 5 : 0;
            gameState.bigBlind = enableBigBlind ? 10 : 0;
            // Always add some bots in offline mode
            gameState.players = [{
                name: 'You',
                chips: 1000,
                cards: [],
                bet: 0,
                isHuman: true,
                isActive: true,
                hasFolded: false
            }];
            // Add AI players
            const aiNames = ['Alice', 'Bob', 'Charlie', 'Diana'];
            for (let i = 0; i < 3; i++) {
                gameState.players.push({
                    name: aiNames[i],
                    chips: 1000,
                    cards: [],
                    bet: 0,
                    isHuman: false,
                    isActive: true,
                    hasFolded: false
                });
            }
            initializeGame();
            startGame();
        }

        function initializeGame() {
            gameState.deck = createDeck();
            gameState.pot = 0;
            gameState.currentBet = 0;
            gameState.communityCards = [];
            gameState.gamePhase = 'preflop';
            gameState.currentPlayer = 0;
            gameState.gameActive = false;

            // Reset all players
            gameState.players.forEach(player => {
                player.cards = [];
                player.bet = 0;
                player.hasFolded = false;
            });

            // Update UI
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('currentVariant').textContent = 'Texas Hold\'em';
            
            updateGameUI();
        }

        function startGame() {
            gameState.gameActive = true;
            updateStatusMessage('Dealing cards...');
            dealNewHand();
        }

        function dealNewHand() {
            if (!gameState.gameActive) return;

            // Move dealer button
            gameState.dealerPosition = (gameState.dealerPosition + 1) % gameState.players.length;

            // Use blinds from gameState if present, else default
            const smallBlind = typeof gameState.smallBlind === 'number' ? gameState.smallBlind : 5;
            const bigBlind = typeof gameState.bigBlind === 'number' ? gameState.bigBlind : 10;

            // Reset for new hand
            gameState.communityCards = [];
            gameState.deck = createDeck();
            gameState.pot = 0;
            gameState.currentBet = bigBlind;
            gameState.currentStreet = 0; // Preflop
            gameState.lastRaiser = null;
            gameState.lastRaiseAmount = bigBlind > 0 ? bigBlind : 1;

            // Reset players and deal cards
            gameState.players.forEach(player => {
                player.cards = [];
                player.bet = 0;
                player.hasFolded = false;
                player.hasActed = false;
                player.hasRaised = false;
                
                let cardsToDeal = 2; // Texas Hold'em
                for (let i = 0; i < cardsToDeal; i++) {
                    player.cards.push(gameState.deck.pop() || {rank: '?', suit: '?', color: 'black'});
                }
            });

            // Post blinds
            const sbIndex = (gameState.dealerPosition + 1) % gameState.players.length;
            const bbIndex = (gameState.dealerPosition + 2) % gameState.players.length;
            
            const smallBlindPlayer = gameState.players[sbIndex];
            smallBlindPlayer.bet = Math.min(smallBlind, smallBlindPlayer.chips);
            smallBlindPlayer.chips -= smallBlindPlayer.bet;
            
            const bigBlindPlayer = gameState.players[bbIndex];
            bigBlindPlayer.bet = Math.min(bigBlind, bigBlindPlayer.chips);
            bigBlindPlayer.chips -= bigBlindPlayer.bet;

            gameState.pot = smallBlindPlayer.bet + bigBlindPlayer.bet;
            
            // Set first player to act (UTG)
            gameState.currentPlayer = (bbIndex + 1) % gameState.players.length;
            gameState.lastRaiser = bbIndex; // The big blind is the initial "raiser"

            updateGameUI();
            updateStatusMessage(`New hand! Blinds are posted. It's ${gameState.players[gameState.currentPlayer].name}'s turn.`);
            showPlayerActions();
        }

        function dealCommunityCards() {
            const fallbackCard = {rank: '?', suit: '?', color: 'black'};
            if (gameState.currentStreet === 1) {
                // Deal flop (3 cards)
                gameState.communityCards.push(gameState.deck.pop() || fallbackCard);
                gameState.communityCards.push(gameState.deck.pop() || fallbackCard);
                gameState.communityCards.push(gameState.deck.pop() || fallbackCard);
            } else if (gameState.currentStreet >= 2) {
                // Deal turn (1 card) or river (1 card)
                gameState.communityCards.push(gameState.deck.pop() || fallbackCard);
            }
            updateGameUI();
        }

        function startBettingRound() {
            gameState.currentBet = 0;
            gameState.lastRaiser = null;
            gameState.lastRaiseAmount = gameState.bigBlind > 0 ? gameState.bigBlind : 1;
            gameState.players.forEach(p => {
                if (!p.hasFolded) {
                    p.bet = 0;
                    p.hasActed = false;
                    p.hasRaised = false;
                }
            });

            // First player to act post-flop is left of dealer
            gameState.currentPlayer = (gameState.dealerPosition + 1) % gameState.players.length;
            while(gameState.players[gameState.currentPlayer].hasFolded) {
                gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.players.length;
            }

            updateGameUI();
            showPlayerActions();
        }

        function onBettingRoundComplete() {
            // Collect bets into the pot
            gameState.players.forEach(p => {
                // This logic was flawed, pot is now updated with each action.
                // We just reset their round bet here.
                p.bet = 0;
            });

            if (gameState.currentStreet < 3) {
                gameState.currentStreet++;
                dealCommunityCards();
                startBettingRound();
            } else {
                endHandShowdown();
            }
        }

        function showPlayerActions() {
            const currentPlayer = gameState.players[gameState.currentPlayer];
            document.getElementById('foldBtn').style.display = 'inline-block';
            document.getElementById('callBtn').style.display = 'inline-block';
            
            const raiseBtn = document.getElementById('raiseBtn');
            raiseBtn.style.display = 'inline-block';
            raiseBtn.disabled = currentPlayer.hasRaised;

            // If it's AI player's turn
            if (!currentPlayer.isHuman) {
                setTimeout(() => aiPlayerAction(currentPlayer), 1500);
            }
        }

        function aiPlayerAction(player) {
            // Simple AI logic for demonstration
            const actions = ['fold', 'call'];
            if (gameState.currentBet === 0 && !player.hasRaised) {
                actions.push('raise');
            } else if (!player.hasRaised) {
                actions.push('raise');
            }
            
            const action = actions[Math.floor(Math.random() * actions.length)];
            playerAction(action);
        }

        function playerAction(action) {
            const currentPlayer = gameState.players[gameState.currentPlayer];
            if (!currentPlayer) return;
            // Only allow the current human player to act in online mode
            if (gameState.mode === 'online' && (!currentPlayer.isHuman || !currentPlayer.isYou)) return;
            currentPlayer.hasActed = true;

            if (action === 'fold') {
                currentPlayer.hasFolded = true;
                updateStatusMessage(`${currentPlayer.name} folded.`);
                // If only one player remains, end hand immediately
                const activePlayers = gameState.players.filter(p => !p.hasFolded);
                if (activePlayers.length === 1) {
                    const winner = activePlayers[0];
                    winner.chips += gameState.pot;
                    updateStatusMessage(`${winner.name} wins ${gameState.pot} as everyone else folded!`);
                    updateGameUI(true);
                    gameState.gameOver = true;
                    if (gameState.mode === 'online') syncGameStateToStorage();
                    setTimeout(() => {
                        if (gameState.mode === 'online') updateLobbyCreditsFromGame();
                        document.getElementById('gameScreen').style.display = 'none';
                        document.getElementById('lobbyScreen').style.display = 'block';
                        // For online, also clear the polling interval if it exists
                        if (window.pokerGameSyncInterval) {
                            clearInterval(window.pokerGameSyncInterval);
                            window.pokerGameSyncInterval = null;
                        }
                    }, 4000);
                    return;
                }
            } else if (action === 'call') {
                const amountToCall = gameState.currentBet - currentPlayer.bet;
                if (amountToCall > 0) {
                    const betAmount = Math.min(amountToCall, currentPlayer.chips);
                    currentPlayer.chips -= betAmount;
                    currentPlayer.bet += betAmount;
                    gameState.pot += betAmount;
                    updateStatusMessage(`${currentPlayer.name} called ${betAmount}.`);
                } else {
                    updateStatusMessage(`${currentPlayer.name} checks.`);
                }
            } else if (action === 'raise') {
                // Only allow raise if it's the current human player's turn and input is present
                let raiseAmount = NaN;
                if (currentPlayer.isHuman && currentPlayer.isYou) {
                    const betInput = document.getElementById('betAmount');
                    raiseAmount = betInput ? parseInt(betInput.value) : NaN;
                }
                if (isNaN(raiseAmount) || raiseAmount <= 0) {
                    alert('Please enter a valid raise amount.');
                    return;
                }
                const amountToCall = gameState.currentBet - currentPlayer.bet;
                const totalBet = amountToCall + raiseAmount;

                if (totalBet > currentPlayer.chips) {
                    alert('You cannot bet more than your available chips!');
                    return;
                }
                // Determine minimum raise: difference between last raise and previous bet, or big blind, or 1
                let minRaise;
                if (gameState.bigBlind > 0) {
                    minRaise = gameState.bigBlind;
                } else if (typeof gameState.lastRaiseAmount === 'number' && gameState.lastRaiseAmount > 0) {
                    minRaise = gameState.lastRaiseAmount;
                } else {
                    minRaise = 1;
                }
                if (raiseAmount < minRaise) {
                    alert(`Minimum raise is ${minRaise}`);
                    return;
                }

                currentPlayer.chips -= totalBet;
                currentPlayer.bet += totalBet;
                gameState.pot += totalBet;
                // Track the last raise amount for correct min raise logic
                gameState.lastRaiseAmount = raiseAmount;
                gameState.currentBet = currentPlayer.bet;
                gameState.lastRaiser = gameState.currentPlayer;
                currentPlayer.hasRaised = true;
                // Reset hasActed for all players except the raiser
                gameState.players.forEach((p, idx) => {
                    if (idx !== gameState.currentPlayer && !p.hasFolded) {
                        p.hasActed = false;
                    }
                });
                updateStatusMessage(`${currentPlayer.name} raised to ${gameState.currentBet}.`);
            }
            
            // Check for winner by fold
            const activePlayers = gameState.players.filter(p => !p.hasFolded);
            if (activePlayers.length === 1) {
                const winner = activePlayers[0];
                winner.chips += gameState.pot;
                updateStatusMessage(`${winner.name} wins ${gameState.pot} as everyone else folded!`);
                updateGameUI(true);
                // Mark game as over and sync for all in online mode
                gameState.gameOver = true;
                if (gameState.mode === 'online') syncGameStateToStorage();
                setTimeout(() => {
                    if (gameState.mode === 'online') {
                        updateLobbyCreditsFromGame();
                        // Reset gameStarted flag so a new game can be started
                        const roomCode = document.getElementById('lobbyRoomCode')?.textContent;
                        if (roomCode) {
                            let roomData = JSON.parse(localStorage.getItem(roomCode));
                            if (roomData) {
                                roomData.gameStarted = false;
                                localStorage.setItem(roomCode, JSON.stringify(roomData));
                            }
                        }
                    }
                    // Return to lobby instead of main menu
                    document.getElementById('gameScreen').style.display = 'none';
                    document.getElementById('lobbyScreen').style.display = 'block';
                }, 4000);
                return;
            }

            // Determine next player
            let nextPlayerIndex = (gameState.currentPlayer + 1) % gameState.players.length;
            while (gameState.players[nextPlayerIndex].hasFolded) {
                nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;
            }

            // Check if betting round is complete
            const allActivePlayersActed = activePlayers.every(p => p.hasActed);
            const allBetsMatched = activePlayers.every(p => p.bet === gameState.currentBet);

            if (allActivePlayersActed && allBetsMatched) {
                onBettingRoundComplete();
            } else {
                gameState.currentPlayer = nextPlayerIndex;
                updateGameUI();
                showPlayerActions();
            }
            // Sync state for all in online mode
            if (gameState.mode === 'online') syncGameStateToStorage();
        }

        // Write gameState to localStorage for online sync
        function syncGameStateToStorage() {
            const roomCode = document.getElementById('lobbyRoomCode')?.textContent;
            if (roomCode) {
                localStorage.setItem(`game_${roomCode}`, JSON.stringify(gameState));
            }
        }

        function endHandShowdown() {
            updateStatusMessage('Showdown! Revealing cards...');
            updateGameUI(true); // Show all cards

            const activePlayers = gameState.players.filter(p => !p.hasFolded);
            if (activePlayers.length > 0) {
                // For now, a real hand evaluation is complex. We'll just pick a random winner.
                const winner = activePlayers[Math.floor(Math.random() * activePlayers.length)];
                winner.chips += gameState.pot;
                updateStatusMessage(`${winner.name} wins the pot of ${gameState.pot}!${gameState.mode === 'offline' ? ' Click Next Hand to play again.' : ' Returning to menu...'}`);
                gameState.gameOver = true;
                if (gameState.mode === 'online') syncGameStateToStorage();
                if (gameState.mode === 'offline') {
                    document.getElementById('nextHandBtn').style.display = 'inline-block';
                } else {
                    setTimeout(() => {
                        if (gameState.mode === 'online') updateLobbyCreditsFromGame();
                        // Return to lobby instead of main menu
                        document.getElementById('gameScreen').style.display = 'none';
                        document.getElementById('lobbyScreen').style.display = 'block';
                    }, 4000);
                }
            } else {
                updateStatusMessage('No winners in showdown. Returning to lobby...');
                gameState.gameOver = true;
                if (gameState.mode === 'online') syncGameStateToStorage();
                setTimeout(() => {
                    document.getElementById('gameScreen').style.display = 'none';
                    document.getElementById('lobbyScreen').style.display = 'block';
                }, 4000);
            }
        }

        function updateGameUI(showAllCards = false) {
            // Update community cards
            const communityCardsContainer = document.getElementById('communityCards');
            communityCardsContainer.innerHTML = '';
            gameState.communityCards.forEach(card => {
                communityCardsContainer.appendChild(createCard(card));
            });

            // Update players display
            const playersContainer = document.getElementById('playersContainer');
            playersContainer.innerHTML = '';
            gameState.players.forEach((player, index) => {
                const playerElement = document.createElement('div');
                playerElement.className = `player ${player.hasFolded ? 'folded' : ''} ${index === gameState.currentPlayer ? 'active' : ''}`;
                
                let positionIndicator = '';
                if (index === gameState.dealerPosition) positionIndicator = ' (D)';
                if (gameState.smallBlind > 0 && index === (gameState.dealerPosition + 1) % gameState.players.length) positionIndicator = ' (SB)';
                if (gameState.bigBlind > 0 && index === (gameState.dealerPosition + 2) % gameState.players.length) positionIndicator = ' (BB)';

                // Show chip count next to name
                playerElement.innerHTML = `
                    <strong>${player.name} (${player.chips})${positionIndicator}</strong><br>
                    Bet: ${player.bet}<br>
                `;
                
                // Show player's cards
                if (player.cards.length > 0) {
                    const cardsDiv = document.createElement('div');
                    cardsDiv.className = 'player-cards';
                    // Show cards if it's the current user, or if it's showdown
                    const faceDown = !player.isYou && !showAllCards;
                    player.cards.forEach(card => {
                        cardsDiv.appendChild(createCard(card, faceDown));
                    });
                    playerElement.appendChild(cardsDiv);
                }
                
                playersContainer.appendChild(playerElement);
            });

            // Update pot and current bet
            document.getElementById('potAmount').textContent = gameState.pot;
            document.getElementById('currentBet').textContent = gameState.currentBet;

            // Sync status message from gameState for all players
            if (gameState.statusMessage) {
                document.getElementById('statusMessage').textContent = gameState.statusMessage;
            }

            // Enable/disable bet input and action buttons for the current human player only
            const betInput = document.getElementById('betAmount');
            const betInputContainer = document.getElementById('betInputContainer');
            const foldBtn = document.getElementById('foldBtn');
            const callBtn = document.getElementById('callBtn');
            const raiseBtn = document.getElementById('raiseBtn');
            const nextHandBtn = document.getElementById('nextHandBtn');
            if (
                (gameState.mode === 'offline' && gameState.players[gameState.currentPlayer]?.isHuman) ||
                (gameState.mode === 'online' && gameState.players[gameState.currentPlayer]?.isHuman && gameState.players[gameState.currentPlayer]?.isYou)
            ) {
                if (betInput) betInput.disabled = false;
                if (betInputContainer) betInputContainer.style.display = '';
                if (foldBtn) foldBtn.disabled = false;
                if (callBtn) callBtn.disabled = false;
                if (raiseBtn) raiseBtn.disabled = false;
            } else {
                if (betInput) betInput.disabled = true;
                if (betInputContainer) betInputContainer.style.display = 'none';
                if (foldBtn) foldBtn.disabled = true;
                if (callBtn) callBtn.disabled = true;
                if (raiseBtn) raiseBtn.disabled = true;
            }
            // Show Next Hand button if game is over in offline mode
            if (nextHandBtn) {
                if (gameState.mode === 'offline' && gameState.gameOver) {
                    nextHandBtn.style.display = 'inline-block';
                } else {
                    nextHandBtn.style.display = 'none';
                }
            }
        }

        function updateLobbyUI(roomCode) {
            const roomData = JSON.parse(localStorage.getItem(roomCode));
            if (!roomData) return;

            // Only update variant, do not overwrite gameState.players (to avoid losing chips info)
            gameState.variant = roomData.variant;

            document.getElementById('lobbyRoomCode').textContent = roomData.code;
            document.getElementById('lobbyGameVariant').textContent = `Variant: ${roomData.variant}`;
            // Also update the variant selector dropdown if present
            const variantSelect = document.getElementById('variantSelect');
            if (variantSelect && variantSelect.value !== roomData.variant) {
                variantSelect.value = roomData.variant;
            }

            const playersList = document.getElementById('playersList');
            playersList.innerHTML = ''; // Clear the list
            
            roomData.players.forEach(player => {
                const playerItem = document.createElement('li');
                playerItem.className = `player-item ${player.isHost ? 'host' : ''}`;
                const hostLabel = player.isHost ? ' (Host)' : '';
                playerItem.innerHTML = `<span>${player.name}${hostLabel}</span><span class="player-status">Ready</span>`;
                playersList.appendChild(playerItem);
            });

            // Host-only Start Game button logic
            const startGameBtn = document.getElementById('startGameBtn');
            // Use the globally stored player name
            const currentPlayerName = window.currentPlayerName;
            const currentPlayer = roomData.players.find(p => p.name === currentPlayerName);
            const isHost = currentPlayer && currentPlayer.isHost;
            if (isHost) {
                startGameBtn.style.display = 'block';
                startGameBtn.disabled = roomData.players.length < 2;
            } else {
                startGameBtn.style.display = 'none';
            }
        }

        function updateStatusMessage(message) {
            gameState.statusMessage = message;
            document.getElementById('statusMessage').textContent = message;
        }

        function backToMenu() {
            // This function is now used to exit a game and return to the main menu.
            // A simple page reload is the easiest way to reset the state.
            window.location.reload();
        }

        // The game no longer starts automatically. The user must click the "Play Offline" button.
        document.addEventListener('DOMContentLoaded', () => {
            // The script is now much simpler and should not have issues loading.
            // Always re-attach Next Hand button handler
            function attachNextHandHandler() {
                const nextHandBtn = document.getElementById('nextHandBtn');
                if (nextHandBtn) {
                    nextHandBtn.onclick = function() {
                        if (gameState.mode === 'offline' && gameState.gameOver) {
                            gameState.gameOver = false;
                            document.getElementById('nextHandBtn').style.display = 'none';
                            // Ensure gameActive is true for new hand
                            gameState.gameActive = true;
                            dealNewHand();
                        }
                    };
                }
            }
            attachNextHandHandler();
            // Also re-attach after every updateGameUI
            const origUpdateGameUI = updateGameUI;
            updateGameUI = function(...args) {
                origUpdateGameUI.apply(this, args);
                attachNextHandHandler();
            };
        });

        // Helper: Update lobby player credits from gameState after a hand and reset gameStarted
        function updateLobbyCreditsFromGame() {
            const roomCode = document.getElementById('lobbyRoomCode')?.textContent;
            if (!roomCode) return;
            let roomData = JSON.parse(localStorage.getItem(roomCode));
            if (!roomData) return;
            // Update chips for each player in the lobby from gameState
            gameState.players.forEach(gp => {
                const rp = roomData.players.find(rp => rp.name === gp.name);
                if (rp) rp.chips = gp.chips;
            });
            // Reset gameStarted so a new game can be started
            roomData.gameStarted = false;
            localStorage.setItem(roomCode, JSON.stringify(roomData));
            updateLobbyUI(roomCode);
        }
    </script>
</body>
</html>